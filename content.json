{"meta":{"title":"李修文","subtitle":null,"description":null,"author":"smilexiu","url":"https://blog.csdn.net/wenxiukeke","root":"/"},"pages":[{"title":"search","text":"","path":"search/index.html","date":"08-20","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"08-20","excerpt":""}],"posts":[{"title":"SpringData系列一@Query注解及@Modifying注解â","text":"很遗憾，这篇文章产生的初衷只是由于三个原因，第一，公司不忙，我太闲了，第二我是真的用到了，感觉这篇博文讲的不错，所以我想copy一遍@Query注解及@Modifying注解，第三，复习一遍。 @Query注解查询适用于所查询的数据无法通过关键字查询得到结果的查询。这种查询可以摆脱像关键字查询那样的约束，将查询直接在相应的接口方法中声明，结构更为清晰，这是Spring Data的特有实现。 索引参数与命名参数 1. 索引参数如下所示，索引值从1开始，查询中”?X”个数需要与方法定义的参数个数相一致，并且顺序也要一致。 12@Query(&quot;SELECT p FROM Person p WHERE p.lastName = ?1 AND p.email = ?2&quot;)List&lt;Person&gt; testQueryAnnotationParams1(String lastName, String email); 注释：上面代码中的?1,?2表示参数的占位符，需要和方法中所传递的参数顺序一致。X是从1开始。 2. 命名参数(推荐使用此方式)：可以定义好参数名，赋值时使用@Param(“参数名”),而不用管顺序。 123// 为@Query注解传递参数的方式1：命名参数@Query(&quot;SELECT p FROM Person p WHERE p.lastName = :lastName AND p.email = :email&quot;)List&lt;Person&gt; testQueryAnnotationParams2(@Param(&quot;email&quot;) String email, @Param(&quot;lastName&quot;) String lastName); 注释：上面代码中:lastName ,:email 表示为参数命名，方法中所传递的参数使用@Param注解标识命名参数。这种方式不用管参数的顺序。 3. 含有LIKE关键字的查询 方式1：可以在占位符上添加”%”,这样在查询方法中就不用添加”%” 123// like查询 Spring Date 允许在占位符上添加%@Query(&quot;SELECT p FROM Person p WHERE p.lastName LIKE %?1% OR p.email LIKE %?2%&quot;)List&lt;Person&gt; testQueryAnnotationLikeParam(String lastName, String email); 12345@Test public void testAnnoationParams3() &#123; List&lt;Person&gt; persons = personRepsitory.testQueryAnnotationLikeParam(&quot;A&quot;, &quot;A@126.com&quot;); System.out.println(persons); &#125; 方式2：不在占位符上添加”%”,这样就必须在查询方法的参数上添加”%” 123// like查询 @Query(&quot;SELECT p FROM Person p WHERE p.lastName LIKE ?1 OR p.email LIKE ?2&quot;) List&lt;Person&gt; testQueryAnnotationLikeParam2(String lastName, String email); 12345@Test public void testAnnoationParams4() &#123; List&lt;Person&gt; persons = personRepsitory.testQueryAnnotationLikeParam2(&quot;%A%&quot;, &quot;%A@126.com%&quot;); System.out.println(persons); &#125; 方式3：在命名参数上添加”%” 123// like查询 使用命名参数 @Query(&quot;SELECT p FROM Person p WHERE p.lastName LIKE %:lastName% OR p.email LIKE %:email%&quot;) List&lt;Person&gt; testQueryAnnotationLikeParam3(@Param(&quot;email&quot;) String email, @Param(&quot;lastName&quot;) String lastName); 4. 使用原生SQL进行查询 123456/** * 设置nativeQuery=true 即可以使用原生的SQL进行查询 * @return */ @Query(value = &quot;SELECT count(id) FROM jpa_persons&quot;, nativeQuery = true) long getTotalCount(); 注释：当设置nativeQuery=true即可以使用原生SQL进行查询 @Modifying注解 在@Query注解中编写JPQL实现DELETE和UPDATE操作的时候必须加上@modifying注解，以通知Spring Data 这是一个DELETE或UPDATE操作。 UPDATE或者DELETE操作需要使用事务，此时需要 定义Service层，在Service层的方法上添加事务操作。 注意JPQL不支持INSERT操作。 1234@Transactional @Modifying @Query(&quot;UPDATE Person p SET p.email = :email WHERE p.id = :id&quot;) void updatePersonEmail(@Param(&quot;id&quot;) Integer id, @Param(&quot;email&quot;) String email); 以上方法，那个like这里，还没有使用过，like查询，不知道这里是否是模糊查询，还没有测试过，不过，之前听别人说，sql语句中不建议用模糊查询，会对数据库产生很大压力，对数据库不友好。","path":"2019/08/30/SpringData系列一@Query注解及@Modifying注解/","date":"08-30","excerpt":"","tags":[]},{"title":"springboot+indexdb","text":"","path":"2019/08/26/springboot-indexdb/","date":"08-26","excerpt":"","tags":[]},{"title":"indexdb","text":"indexdb概念了解写这篇文章主要是，因为项目中用到了这个东西，这篇文章的主要内容，我主要是记录一下，当时我完成app登录拦截功能时的思路。做功能之前我主要去网上参考了几篇文章，首先我去看了一下概念，了解概念以后，就分别去了解了一下indexdb是如何建库建表新增查找数据的。链接我提供一下，阮一峰网络日志 indexdb增删改查案例这里提供一篇参考博客indexdb增删改查实例因为我要实现登录功能，大概思路是创建数据库，然后创建数据表，将用户名存进去，下次登录直接在本地判断用户名是否存在即可，退出登录以后，先关闭数据库，在删除数据库。下面是我的测试代码，亲测可用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;indexdb&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; onclick=&quot;addData(myDB.db,&apos;students&apos;)&quot; value=&quot;新增数据&quot;&gt;&lt;input type=&quot;button&quot; onclick=&quot;closeDB(myDB.db)&quot; value=&quot;关闭数据库&quot;&gt;&lt;input type=&quot;button&quot; onclick=&quot;deleteDB(myDB.name)&quot; value=&quot;删除数据库&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; var myDB = &#123; name: &apos;test&apos;, version: 1, db: null &#125;; var students = [&#123; id: 1001, name: &quot;Byron&quot;, age: 24 &#125;, &#123; id: 1002, name: &quot;Frank&quot;, age: 30 &#125;, &#123; id: 1003, name: &quot;Aaron&quot;, age: 26 &#125;, &#123; id: 1004, name: &quot;Casper&quot;, age: 26 &#125;]; function openDB(name, version) &#123; var version = version || 1; var request = window.indexedDB.open(name, version); request.onerror = function (e) &#123; console.log(e.currentTarget.error.message); &#125;; request.onsuccess = function (e) &#123; myDB.db = e.target.result; &#125;; request.onupgradeneeded = function (e) &#123; var db = e.target.result; if (!db.objectStoreNames.contains(&apos;students&apos;)) &#123; var store = db.createObjectStore(&apos;students&apos;, &#123; keyPath: &apos;id&apos; &#125;); store.createIndex(&apos;nameIndex&apos;, &apos;name&apos;, &#123; unique: true &#125;); store.createIndex(&apos;ageIndex&apos;, &apos;age&apos;, &#123; unique: false &#125;); &#125; console.log(&apos;DB version changed to &apos; + version); &#125;; &#125; function closeDB(db) &#123; db.close(); &#125; function deleteDB(name) &#123; indexedDB.deleteDatabase(name); &#125; function addData(db, storeName) &#123; var trans = db.transaction([storeName], &apos;readwrite&apos;); var store = trans.objectStore(storeName); for (var i = 0; i &lt; students.length; i++) &#123; store.add(students[i]); &#125; &#125; function getDataByKey(db, storeName, value) &#123; var transaction = db.transaction(storeName, &apos;readwrite&apos;); var store = transaction.objectStore(storeName); var request = store.get(value); request.onsuccess = function (e) &#123; var student = e.target.result; console.log(student.name); &#125;; &#125; function updateDataByKey(db, storeName, value) &#123; var transaction = db.transaction(storeName, &apos;readwrite&apos;); var store = transaction.objectStore(storeName); var request = store.get(value); request.onsuccess = function (e) &#123; var student = e.target.result; student.age = 35; store.put(student); &#125;; &#125; function deleteDataByKey(db, storeName, value) &#123; var transaction = db.transaction(storeName, &apos;readwrite&apos;); var store = transaction.objectStore(storeName); store.delete(value); &#125; function clearObjectStore(db, storeName) &#123; var transaction = db.transaction(storeName, &apos;readwrite&apos;); var store = transaction.objectStore(storeName); store.clear(); &#125; function deleteObjectStore(db, storeName) &#123; var transaction = db.transaction(storeName, &apos;versionchange&apos;); db.deleteObjectStore(storeName); &#125; function fetchStoreByCursor(db, storeName) &#123; var transaction = db.transaction(storeName); var store = transaction.objectStore(storeName); var request = store.openCursor(); request.onsuccess = function (e) &#123; var cursor = e.target.result; if (cursor) &#123; console.log(cursor.key); var currentStudent = cursor.value; console.log(currentStudent.name); cursor.continue(); &#125; &#125;; &#125; function getDataByIndex(db, storeName) &#123; var transaction = db.transaction(storeName); var store = transaction.objectStore(storeName); var index = store.index(&quot;ageIndex&quot;); index.get(26).onsuccess = function (e) &#123; var student = e.target.result; console.log(student.id); &#125; &#125; function getMultipleData(db, storeName) &#123; var transaction = db.transaction(storeName); var store = transaction.objectStore(storeName); var index = store.index(&quot;nameIndex&quot;); var request = index.openCursor(null, IDBCursor.prev); request.onsuccess = function (e) &#123; var cursor = e.target.result; if (cursor) &#123; var student = cursor.value; console.log(student.name); cursor.continue(); &#125; &#125; &#125; openDB(myDB.name,myDB.version);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面是一个封装好的indexdb代码，里面的方法我就暂时研究了indexdb初始化数据库，indexdb新建表并且添加数据，indexdb关闭数据库并且删除数据库，其他的暂时还没有用到了，简单看了一下，就没有测试了，感兴趣的朋友就自己测试吧，这里简单做一个记录，方便以后自己查看和回忆。","path":"2019/08/26/indexdb/","date":"08-26","excerpt":"","tags":[]},{"title":"myfirstblog","text":"最近搭建了一个自己的博客，用的是默认主题，（可能后期会去copy一个漂亮的主题）搭建博客的初衷是为了记录自己的学习历程，也许很low，也许没有任何参考价值，不过我还是要写，主要原因呢，还想要强迫一下自己学习，通过日记的形式记录自己一天干了啥，而不是傻傻的一天发呆就这样过去了，最近看了同事的博客，看了以前和他一起刚入公司时，他的一些学习历程，当时心里就很不是滋味，看看人家在学习的时候，你在干嘛呀，对吧。假装对自己说，还来得及，也许留下的时间不多了，顶多半年吧，半年以后，能否成为一个稍微看起来优秀的程序员嘛，这是一个未知数，不过，我想拼一把，身体里好战好勇的因子告诉我，这是一个挑战，接受它吧。那就接受任务了，希望最后不要不要打了自己的老脸才好。好啦，这就是我第一篇博客简介啦，接下来的每一天就记录学习日报。","path":"2019/08/21/myfirstblog/","date":"08-21","excerpt":"","tags":[]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2019/08/19/hello-world/","date":"08-19","excerpt":"","tags":[]}]}